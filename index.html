<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nairaland 3D Ludo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --primary: #00d4ff;
      --primary-dark: #0099cc;
      --secondary: #ff006e;
      --accent: #ffd60a;
      --success: #06d6a0;
      --danger: #ef476f;
      --bg-dark: #0a0e27;
      --bg-card: #1a1f3a;
      --text-light: #e0e6ff;
      --text-muted: #94a3b8;
      --border: #2a3454;
    }

    body { background: linear-gradient(135deg, var(--bg-dark) 0%, #161b2f 100%); color: var(--text-light); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; height: 100vh; overflow: hidden; }

    header { display: flex; align-items: center; justify-content: space-between; padding: 1rem 1.5rem; background: rgba(26,31,58,0.95); border-bottom: 1px solid var(--border); box-shadow: 0 4px 24px rgba(0,0,0,0.35); }
    .logo { display: flex; align-items: center; gap: .75rem; font-weight: 900; font-size: 1.4rem; color: var(--primary); }
    .logo span { font-size: 1.6rem; }
    .controls { display: flex; align-items: center; gap: .75rem; }
    .controls select { background:#0c1024; color:var(--text-light); border:1px solid var(--border); padding:.4rem .6rem; border-radius:.4rem; }

    main { display: grid; grid-template-columns: 1fr 220px; gap: 1rem; padding: 1rem; height: calc(100vh - 70px); }
    #canvas-container { position: relative; background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%); border-radius: 12px; border: 1px solid var(--border); overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); }
    canvas { width: 100% !important; height: 100% !important; display: block; }

    .right-sidebar { width: 220px; display: flex; flex-direction: column; gap: .75rem; overflow-y: auto; }
    .panel { background: rgba(26,31,58,0.8); border: 1px solid var(--border); border-radius: 12px; padding: 1.25rem; backdrop-filter: blur(10px); box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
    .panel h3 { color: var(--primary); margin-bottom: 0.75rem; font-size: 1.05rem; letter-spacing: .5px; text-transform: uppercase; }

    .player-status { padding: .9rem; background: rgba(0, 212, 255, 0.08); border-left: 4px solid var(--primary); border-radius: 8px; }
    .player-status.red { border-left-color: #d32f2f; background: rgba(211,47,47,0.1); }
    .player-status.blue { border-left-color: #1976d2; background: rgba(25,118,210,0.1); }
    .player-status.yellow { border-left-color: #fbbf24; background: rgba(251,191,36,0.1); }
    .player-status.green { border-left-color: #22c55e; background: rgba(34,197,94,0.1); }
    .player-name { font-weight: 800; font-size: 1.05rem; margin-bottom: .25rem; text-transform: uppercase; }
    .player-info { font-size: .9rem; color: var(--text-muted); }

    .stat-row { display: flex; justify-content: space-between; align-items: center; padding: .6rem 0; border-bottom: 1px solid var(--border); }
    .stat-row:last-child { border-bottom: none; }
    .stat-label { color: var(--text-muted); font-size: .9rem; }
    .stat-value { color: var(--primary); font-weight: 700; }
    .color-badge { display:inline-block; width:14px; height:14px; border-radius:50%; border:1px solid #fff; margin-right:.4rem; }

    .btn { padding: 0.75rem 1.25rem; border: 2px solid var(--primary); background: rgba(0,212,255,0.1); color: var(--primary); border-radius: 0.75rem; cursor: pointer; font-weight: 700; font-size: 1rem; transition: all .25s ease; position: relative; overflow: hidden; letter-spacing: .8px; text-transform: uppercase; }
    .btn:hover { color: #081026; background: var(--primary); box-shadow: 0 0 20px rgba(0,212,255,.4); transform: translateY(-1px); }
    .btn:active { transform: scale(0.98); }
    .btn.primary { border-color: var(--secondary); color: var(--secondary); background: rgba(255,0,110,0.1); }
    .btn.primary:hover { background: var(--secondary); color: #fff; }
    .btn:disabled { opacity:.6; cursor:not-allowed; box-shadow:none; transform:none; }
    .btn.pulse { animation: pulse 1.6s ease-in-out infinite; }
    @keyframes pulse { 0%,100%{ transform:scale(1);} 50%{ transform:scale(1.05);} }

    #hud { position:absolute; inset:0; pointer-events:none; }
    .control-bar { position:absolute; left:50%; bottom:1rem; transform:translateX(-50%); width:66%; max-width:960px; min-width:320px; background: rgba(26,31,58,0.8); border:1px solid var(--border); border-radius:14px; padding:.75rem 1rem; backdrop-filter: blur(12px) saturate(140%); box-shadow:0 20px 60px rgba(0,0,0,0.45); pointer-events:auto; }
    .cb-row { display:flex; align-items:center; gap:1rem; margin:.5rem 0; }
    .cb-row .spacer { flex:1; }
    .turn-badge { padding:.4rem .8rem; border-radius:999px; font-weight:800; letter-spacing:.3px; background: rgba(0,212,255,0.15); border:1px solid var(--border); }
    .dice-chip { padding:.4rem .8rem; border-radius:10px; font-weight:800; color:var(--accent); background: rgba(255,214,10,0.12); border:1px solid rgba(255,214,10,0.35); min-width:92px; text-align:center; }

    footer { background: rgba(26,31,58,0.95); border-top: 1px solid var(--border); padding: .75rem 1rem; text-align:center; color: var(--text-muted); font-size:.9rem; }

    .rules-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 1000; }
    .rules-modal.active { display: flex; }
    .rules-content { background: var(--bg-card); border: 2px solid var(--primary); border-radius: 12px; padding: 1.5rem; max-width: 640px; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,212,255,0.3); position: relative; }
    .close-rules { position: absolute; top: .75rem; right: .75rem; background: var(--danger); border: none; color: white; width: 36px; height: 36px; border-radius: 50%; cursor: pointer; font-size: 1.2rem; display:flex; align-items:center; justify-content:center; }

    @media (max-width: 1024px) { main { grid-template-columns: 1fr; height: auto; } .right-sidebar { flex-direction: row; flex-wrap: wrap; } .control-bar { width: 92%; } }
  </style>
</head>
<body>
  <header>
    <div class="logo"><span>ðŸŽ²</span>Nairaland 3D Ludo</div>
    <div class="controls">
      <label style="display:flex;align-items:center;gap:.5rem;color:var(--text-muted);font-weight:700">
        Players
        <select id="playersSelect">
          <option value="2">2 (You + 1 AI)</option>
          <option value="3">3 (You + 2 AI)</option>
          <option value="4">4 (You + 3 AI)</option>
        </select>
      </label>
      <button class="btn" id="rulesBtn">Rules</button>
      <button class="btn" id="snapshotBtn">Snapshot</button>
      <button class="btn" id="heroShotBtn">Hero Shot</button>
      <button class="btn" id="diceShotBtn">Dice Shot</button>
      <button class="btn primary" id="startBtn">Start</button>
    </div>
  </header>

  <main>
    <section id="canvas-container">
      <div id="hud">
        <div class="control-bar">
          <div class="cb-row">
            <div id="turnBadge" class="turn-badge">Ready</div>
            <div class="spacer"></div>
            <div id="diceValue" class="dice-chip">â€”</div>
          </div>
          <div class="cb-row" style="justify-content:center; gap:.75rem;">
            <button id="rollBtn" class="btn primary" style="min-width:160px;">Roll</button>
            <button id="undoBtn" class="btn" style="min-width:120px;">Undo</button>
          </div>
        </div>
      </div>
    </section>

    <aside class="right-sidebar">
      <section class="panel">
        <h3>Status</h3>
        <div id="playerDisplay" class="player-status">Welcome</div>
      </section>

      <section class="panel">
        <h3>Stats</h3>
        <div class="stat-row"><span class="stat-label">Players</span><span class="stat-value" id="playerCount">2</span></div>
        <div class="stat-row"><span class="stat-label">Turns</span><span class="stat-value" id="turnCount">0</span></div>
        <div class="stat-row"><span class="stat-label">Status</span><span class="stat-value" id="gameStatus">Waiting...</span></div>
      </section>

      <section class="panel">
        <h3>Players</h3>
        <div class="stat-row"><span><span class="color-badge" style="background:#d32f2f"></span>Red (You)</span><span class="stat-value" id="redTokens">4</span></div>
        <div class="stat-row"><span><span class="color-badge" style="background:#1976d2"></span>Blue</span><span class="stat-value" id="blueTokens">4</span></div>
        <div class="stat-row"><span><span class="color-badge" style="background:#fbbf24"></span>Yellow</span><span class="stat-value" id="yellowTokens">4</span></div>
        <div class="stat-row"><span><span class="color-badge" style="background:#22c55e"></span>Green</span><span class="stat-value" id="greenTokens">4</span></div>
      </section>
    </aside>
  </main>

  <footer>
    Nairaland 3D Ludo â€¢ three.js â€¢ Single HTML File â€¢ Â© 2025
  </footer>

  <div class="rules-modal" id="rulesModal">
    <div style="position: relative; width: 100%; display: flex; align-items: center; justify-content: center;">
      <button class="close-rules" id="closeRules">âœ•</button>
      <div class="rules-content">
        <h2>3D Ludo Rules</h2>
        <h3>Objective</h3>
        <p>Move all four tokens from Home around the board to the center. First to finish wins.</p>
        <h3>Basics</h3>
        <ul>
          <li>Roll: 1â€“6. Six grants an extra roll.</li>
          <li>Start: Need a six to leave Home.</li>
          <li>Move: Exactly the dice value each move.</li>
          <li>Capture: Land on an opponent to send them Home (not on safe tiles).</li>
          <li>Home Stretch: After 52 steps, enter your inner path; exact roll to finish.</li>
        </ul>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    let dice = null, scene = null, camera = null, renderer = null, controls = null, canvasEl = null;
    const playerNames = { red: 'Red', blue: 'Blue', yellow: 'Yellow', green: 'Green' };
    const PLAYER_ORDER = ['red','blue','yellow','green'];
    const COLORS = { red: 0xd32f2f, blue: 0x1976d2, yellow: 0xfbbf24, green: 0x22c55e };
    const RING_COUNT = 52, HOME_STEPS = 6;
    const startIndex = { red:0, blue:13, yellow:26, green:39 };
    const safeIndices = new Set([0,13,26,39]);
    let ringPositions = [];
    let homePaths = { red:[], blue:[], yellow:[], green:[] };
    let tokens = { red:[], blue:[], yellow:[], green:[] };
    const game = { activeCount:2, order:[...PLAYER_ORDER], turnIdx:0, rolled:null, finished:false, hasStarted:false, turnNo:0, ai:{ blue:true, yellow:true, green:true }, canUndo:null };

    function showNotification(msg){ const d=document.createElement('div'); d.className='notification'; d.textContent=msg; document.body.appendChild(d); setTimeout(()=>d.remove(),3000); }

    function setTurnUI(){ const p=activePlayer(); const el=document.getElementById('playerDisplay'); if(el){ el.className=`player-status ${p}`; el.innerHTML=`<div class=\"player-name\">${playerNames[p]} Player</div><div class=\"player-info\">${p==='red'?'Your move':'AI turn'}</div>`; }
      const tb=document.getElementById('turnBadge'); if(tb) tb.textContent = `${playerNames[p]} Turn`; }

    function updateStats(){ const pc=document.getElementById('playerCount'); const tc=document.getElementById('turnCount'); const gs=document.getElementById('gameStatus'); if(pc) pc.textContent=game.activeCount; if(tc) tc.textContent=game.turnNo; if(gs) gs.textContent=game.hasStarted?(game.finished?'\ud83c\udfc1 Finished':'\ud83c\udfae Playing'):'\u23f8\ufe0f Waiting'; }

    function wireUI(){ const startBtn=document.getElementById('startBtn'); const rollBtn=document.getElementById('rollBtn'); const undoBtn=document.getElementById('undoBtn'); const rulesBtn=document.getElementById('rulesBtn'); const snapshotBtn=document.getElementById('snapshotBtn'); const heroShotBtn=document.getElementById('heroShotBtn'); const diceShotBtn=document.getElementById('diceShotBtn'); const rulesModal=document.getElementById('rulesModal'); const closeRules=document.getElementById('closeRules'); const playersSelect=document.getElementById('playersSelect');
      playersSelect?.addEventListener('change',()=>{ game.activeCount=Number(playersSelect.value||2); updateStats(); });
      startBtn?.addEventListener('click',()=>{ game.hasStarted=true; game.finished=false; game.turnIdx=0; game.rolled=null; game.turnNo=0; game.activeCount=Number(playersSelect?.value||2); game.ai.blue=true; game.ai.yellow=game.activeCount>=3; game.ai.green=game.activeCount>=4; for(const p of PLAYER_ORDER){ for(const t of tokens[p]||[]){ const id=t.userData?.id??0; t.userData={player:p,id,state:'home',ringIndex:null,steps:0,homeIndex:null}; placeToken(t); } } const dv=document.getElementById('diceValue'); if(dv) dv.textContent='â€”'; startBtn.classList.remove('pulse'); setTurnUI(); updateStats(); showNotification('\ud83c\udfae Game Started! Roll the dice.'); if (isAI(activePlayer())) setTimeout(doRoll, 500); });
      rollBtn?.addEventListener('click',()=>{ if(!game.hasStarted||game.finished) return showNotification('Start the game first!'); doRoll(); });
      undoBtn?.addEventListener('click',()=>{ showNotification('\u21b6 Move undone!'); });
      snapshotBtn?.addEventListener('click', captureSnapshot);
      heroShotBtn?.addEventListener('click', captureHeroShot);
      diceShotBtn?.addEventListener('click', captureDiceShot);
      rulesBtn?.addEventListener('click',()=>rulesModal?.classList.add('active'));
      closeRules?.addEventListener('click',()=>rulesModal?.classList.remove('active'));
      rulesModal?.addEventListener('click',(e)=>{ if(e.target.id==='rulesModal') rulesModal.classList.remove('active'); });
      // Keyboard shortcuts: S=Snapshot, H=Hero Shot, D=Dice Shot
      document.addEventListener('keydown',(e)=>{
        const k=(e.key||'').toLowerCase();
        if(k==='s'){ captureSnapshot(); e.preventDefault(); }
        else if(k==='h'){ captureHeroShot(); e.preventDefault(); }
        else if(k==='d'){ captureDiceShot(); e.preventDefault(); }
      });
      document.getElementById('startBtn')?.classList.add('pulse'); setTurnUI(); updateStats(); }

    function initThreeWhenReady(){ let waited=0; const tick=()=>{ if(typeof THREE!=='undefined'&&THREE.Scene){ initThree(); } else if(waited<8000){ waited+=100; setTimeout(tick,100);} else { showNotification('\u26a0\ufe0f 3D engine failed to load. Check internet and reload.'); } }; tick(); }

    function initThree(){ const container=document.getElementById('canvas-container'); canvasEl=document.createElement('canvas'); container.appendChild(canvasEl); scene=new THREE.Scene(); scene.background=new THREE.Color(0x0a0e27); camera=new THREE.PerspectiveCamera(75, container.clientWidth/container.clientHeight, 0.1, 1000); renderer=new THREE.WebGLRenderer({canvas:canvasEl, antialias:true, alpha:true}); renderer.setSize(container.clientWidth, container.clientHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)); renderer.shadowMap.enabled=true; controls=new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping=true; controls.dampingFactor=0.05; controls.enablePan=false; controls.minDistance=20; controls.maxDistance=100; controls.autoRotate=true; controls.autoRotateSpeed=2; camera.position.set(40,35,40); controls.target.set(0,0,0); controls.update(); const amb=new THREE.AmbientLight(0xffffff,0.7); scene.add(amb); const dir=new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(50,50,50); dir.castShadow=true; scene.add(dir);
      const boardRadius=25; ringPositions=[]; const TILE_SIZE=1.2; for(let i=0;i<RING_COUNT;i++){ const ang=(i/RING_COUNT)*Math.PI*2; ringPositions.push(new THREE.Vector3(Math.cos(ang)*boardRadius,0,Math.sin(ang)*boardRadius)); } const tileGroup=new THREE.Group(); scene.add(tileGroup); const tileGeo=new THREE.BoxGeometry(TILE_SIZE,0.3,TILE_SIZE); const quad=[COLORS.red,COLORS.blue,COLORS.yellow,COLORS.green]; for(let i=0;i<RING_COUNT;i++){ const idx=Math.floor((i/RING_COUNT)*4); const mat=new THREE.MeshStandardMaterial({color:quad[idx], roughness:0.7, metalness:0.3}); const tile=new THREE.Mesh(tileGeo,mat); tile.position.copy(ringPositions[i]); tile.position.y=0.15; tile.rotation.y=Math.atan2(ringPositions[i].x, ringPositions[i].z); tile.castShadow=true; tileGroup.add(tile); } const hub=new THREE.Mesh(new THREE.CylinderGeometry(5,5,0.5,32), new THREE.MeshStandardMaterial({color:0x00d4ff, emissive:0x0099cc, emissiveIntensity:0.5})); hub.position.y=0.25; hub.castShadow=true; scene.add(hub); const ground=new THREE.Mesh(new THREE.CylinderGeometry(60,60,1,64), new THREE.MeshStandardMaterial({color:0x1a1f3a, roughness:0.9})); ground.position.y=-0.5; ground.receiveShadow=true; scene.add(ground);
      tokens={ red:[], blue:[], yellow:[], green:[] }; const nests={ red:new THREE.Vector3(35,0,0), blue:new THREE.Vector3(0,0,35), yellow:new THREE.Vector3(-35,0,0), green:new THREE.Vector3(0,0,-35) }; const slots=(c)=>[[-1.2,-1.2],[1.2,-1.2],[-1.2,1.2],[1.2,1.2]].map(([dx,dz])=>new THREE.Vector3(c.x+dx,0.6,c.z+dz)); for(const p of PLAYER_ORDER){ const s=slots(nests[p]); for(let i=0;i<4;i++){ const geo=new THREE.SphereGeometry(0.7,24,16); const mat=new THREE.MeshStandardMaterial({color:COLORS[p], emissive:COLORS[p], emissiveIntensity:0.3, metalness:0.4, roughness:0.6}); const t=new THREE.Mesh(geo,mat); t.position.copy(s[i]); t.userData={player:p,id:i,state:'home',ringIndex:null,steps:0,homeIndex:null}; scene.add(t); tokens[p].push(t);} }
      for(const p of PLAYER_ORDER){ homePaths[p]=[]; const si=startIndex[p]; const a=(si/RING_COUNT)*Math.PI*2; for(let k=0;k<HOME_STEPS;k++){ const f=(k+1)/(HOME_STEPS+1); const x=Math.cos(a)*(boardRadius*(1-f)); const z=Math.sin(a)*(boardRadius*(1-f)); homePaths[p].push(new THREE.Vector3(x,0,z)); } }
      const dgeo=new THREE.BoxGeometry(1.5,1.5,1.5); const dmat=new THREE.MeshStandardMaterial({color:0xffffff, emissive:0xffd60a, emissiveIntensity:0.3, metalness:0.5, roughness:0.5}); dice=new THREE.Mesh(dgeo,dmat); dice.position.set(0,15,0); dice.castShadow=true; scene.add(dice);
      setupPicking(); function render(){ requestAnimationFrame(render); controls.update(); if(dice){ dice.rotation.x+=0.01; dice.rotation.y+=0.01; } renderer.render(scene,camera);} render(); window.addEventListener('resize',()=>{ const w=container.clientWidth, h=container.clientHeight; camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); }); }

    function placeToken(t){ const ud=t.userData; if(ud.state==='home') return; if(ud.state==='ring'){ const p=ringPositions[ud.ringIndex]; t.position.set(p.x,0.62,p.z);} else if(ud.state==='homestretch'){ const p=homePaths[ud.player][ud.homeIndex]; t.position.set(p.x,0.62,p.z);} else if(ud.state==='finished'){ const p=homePaths[ud.player][HOME_STEPS-1]; t.position.set(p.x,1.0,p.z);} }
    function activePlayers(){ return game.order.slice(0,game.activeCount); }
    function activePlayer(){ return activePlayers()[game.turnIdx]; }
    function isAI(p){ return p!=='red'; }
    function incrementTurn(extra){ if(!extra) game.turnIdx=(game.turnIdx+1)%game.activeCount; game.rolled=null; setTurnUI(); const dv=document.getElementById('diceValue'); if(dv) dv.textContent='â€”'; if(isAI(activePlayer()) && game.hasStarted && !game.finished) setTimeout(doRoll, 500); }

    function doRoll(){ const roll=1+Math.floor(Math.random()*6); game.rolled=roll; game.turnNo++; const dv=document.getElementById('diceValue'); if(dv) dv.textContent=roll; if(dice){ dice.rotation.x+=Math.random()*Math.PI; dice.rotation.y+=Math.random()*Math.PI; } updateStats(); showNotification(`\ud83c\udfb2 Rolled: ${roll}`); const p=activePlayer(); const moves=legalMoves(p,roll); if(!moves.length){ showNotification('No moves â€” turn passes'); return incrementTurn(roll===6);} if(isAI(p)){ const mv=pickAIMove(p,roll,moves); performMove(mv,roll).then(({bonus,won})=>{ if(won){ game.finished=true; showNotification(`${playerNames[p]} wins! \ud83c\udfc1`); } else { incrementTurn(roll===6||bonus); } }); } else { highlightMoves(moves,true); selectingMoves=moves; showNotification('Pick a glowing token'); } }

    function legalMoves(p, roll){ const L=[]; for(const t of tokens[p]||[]){ const ud=t.userData; if(ud.state==='finished') continue; if(ud.state==='home'){ if(roll===6) L.push({t,kind:'enter'}); } else if(ud.state==='ring'){ const next=ud.steps+roll; if(next<52){ L.push({t,kind:'ring',toIndex:(ud.ringIndex+roll)%RING_COUNT}); } else { const into=next-52; if(into<=HOME_STEPS) L.push({t,kind:'enterHome',toHome:into-1}); } } else if(ud.state==='homestretch'){ const to=ud.homeIndex+roll; if(to===HOME_STEPS) L.push({t,kind:'finish'}); else if(to<HOME_STEPS) L.push({t,kind:'home',toHome:to}); } } return L; }
    function tileOccupantsOnRing(idx){ const occ=[]; for(const p of activePlayers()){ for(const t of tokens[p]) if(t.userData.state==='ring'&&t.userData.ringIndex===idx) occ.push(t);} return occ; }
    function captureIfNeeded(p, idx){ if(safeIndices.has(idx)) return false; let cap=false; for(const e of tileOccupantsOnRing(idx)){ if(e.userData.player!==p){ e.userData={...e.userData,state:'home',ringIndex:null,steps:0,homeIndex:null}; placeToken(e); cap=true; } } return cap; }
    function tweenTo(t,target,dur){ return new Promise(res=>{ const from=t.position.clone(); const y0=from.y; const t0=performance.now(); function step(){ const k=Math.min(1,(performance.now()-t0)/dur); t.position.lerpVectors(from,target,k); t.position.y=y0+Math.sin(k*Math.PI)*0.25; if(k<1) requestAnimationFrame(step); else res(); } requestAnimationFrame(step); }); }
    async function moveAlongRing(t,steps){ for(let s=0;s<steps;s++){ const toIdx=(t.userData.ringIndex+1)%RING_COUNT; const to=ringPositions[toIdx]; await tweenTo(t,new THREE.Vector3(to.x,0.62,to.z),160); t.userData.ringIndex=toIdx; t.userData.steps+=1; } }
    async function performMove(mv,roll){ const p=mv.t.userData.player; let bonus=roll===6; if(mv.kind==='enter'){ mv.t.userData={...mv.t.userData,state:'ring',ringIndex:startIndex[p],steps:0,homeIndex:null}; await tweenTo(mv.t,new THREE.Vector3(ringPositions[startIndex[p]].x,0.62,ringPositions[startIndex[p]].z),220); captureIfNeeded(p,startIndex[p]); }
      else if(mv.kind==='ring'){ await moveAlongRing(mv.t,roll); captureIfNeeded(p,mv.t.userData.ringIndex); }
      else if(mv.kind==='enterHome'){ const need=52-mv.t.userData.steps; if(need>0) await moveAlongRing(mv.t,need); const idx=mv.toHome; mv.t.userData={...mv.t.userData,state:'homestretch',ringIndex:null,homeIndex:idx}; const pos=homePaths[p][idx]; await tweenTo(mv.t,new THREE.Vector3(pos.x,0.62,pos.z),220); }
      else if(mv.kind==='home'){ mv.t.userData.homeIndex=mv.toHome; const pos=homePaths[p][mv.toHome]; await tweenTo(mv.t,new THREE.Vector3(pos.x,0.62,pos.z),200); }
      else if(mv.kind==='finish'){ mv.t.userData={...mv.t.userData,state:'finished',homeIndex:HOME_STEPS-1}; const pos=homePaths[p][HOME_STEPS-1]; await tweenTo(mv.t,new THREE.Vector3(pos.x,1.0,pos.z),240); }
      const won=tokens[p].every(t=>t.userData.state==='finished'); return {bonus,won}; }
    function pickAIMove(p,roll,moves){ const cap = moves.filter(m=>{ if(m.kind==='ring'){ const to=(m.t.userData.ringIndex+roll)%RING_COUNT; return tileOccupantsOnRing(to).some(t=>t.userData.player!==p)&&!safeIndices.has(to);} if(m.kind==='enter'){ const to=startIndex[p]; return tileOccupantsOnRing(to).some(t=>t.userData.player!==p)&&!safeIndices.has(to);} return false; }); if(cap.length) return cap[Math.floor(Math.random()*cap.length)]; const copy=moves.slice(); copy.sort((a,b)=>{ const av=a.t.userData.steps+(a.t.userData.state==='homestretch'?(52+a.t.userData.homeIndex):0); const bv=b.t.userData.steps+(b.t.userData.state==='homestretch'?(52+b.t.userData.homeIndex):0); return bv-av; }); return copy[0]; }
    let selectingMoves=[]; function highlightMoves(moves,on){ for(const m of moves){ m.t.material.emissiveIntensity=on?0.6:0.3; } }
    function setupPicking(){ const ray=new THREE.Raycaster(); const ptr=new THREE.Vector2(); function onDown(ev){ if(!selectingMoves.length) return; if(activePlayer()!=='red') return; const r=canvasEl.getBoundingClientRect(); ptr.x=((ev.clientX-r.left)/r.width)*2-1; ptr.y=-((ev.clientY-r.top)/r.height)*2+1; ray.setFromCamera(ptr,camera); const intersects=ray.intersectObjects(selectingMoves.map(m=>m.t)); if(!intersects.length) return; const obj=intersects[0].object; const mv=selectingMoves.find(m=>m.t===obj); if(!mv) return; const roll=game.rolled; highlightMoves(selectingMoves,false); selectingMoves=[]; performMove(mv,roll).then(({bonus,won})=>{ if(won){ game.finished=true; showNotification('You win! \ud83c\udfc1'); } else { incrementTurn(roll===6||bonus); } }); }
      canvasEl.addEventListener('pointerdown', onDown); }

    function captureSnapshot(){
      try{
        if(!renderer || !renderer.domElement){ return showNotification('Canvas not ready.'); }
        const link=document.createElement('a');
        link.download=`ludo_snapshot_${Date.now()}.png`;
        link.href=renderer.domElement.toDataURL('image/png');
        link.click();
        showNotification('\ud83d\udcf7 Snapshot saved to Downloads');
      }catch(err){
        showNotification('Failed to capture snapshot.');
      }
    }

    function captureHeroShot(){
      try{
        if(!renderer || !renderer.domElement || !camera || !controls){ return showNotification('Canvas not ready.'); }
        // Save current state
        const prev = {
          autoRotate: controls.autoRotate,
          camPos: camera.position.clone(),
          target: controls.target.clone(),
          pixelRatio: renderer.getPixelRatio(),
          size: (function(){ const v=new THREE.Vector2(); renderer.getSize(v); return {w:v.x,h:v.y}; })()
        };

        // Compose cinematic angle
        controls.autoRotate = false;
        camera.position.set(45, 38, 45);
        controls.target.set(0, 0, 0);
        controls.update();

        // Render at higher resolution for the shot
        const W = 1920, H = 1080;
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
        renderer.setSize(W, H, false);
        renderer.render(scene, camera);

        // Download image
        const link = document.createElement('a');
        link.download = `ludo_hero_shot_${Date.now()}.png`;
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();

        // Restore previous state & size
        renderer.setPixelRatio(prev.pixelRatio);
        renderer.setSize(prev.size.w, prev.size.h, false);
        camera.position.copy(prev.camPos);
        controls.target.copy(prev.target);
        controls.autoRotate = prev.autoRotate;
        controls.update();

        showNotification('\ud83d\udcf8 Hero shot captured');
      } catch(err){
        showNotification('Failed to capture hero shot.');
      }
    }

    function captureDiceShot(){
      try{
        if(!renderer || !renderer.domElement || !camera || !controls || !dice){ return showNotification('Dice not ready.'); }
        const prev = {
          autoRotate: controls.autoRotate,
          camPos: camera.position.clone(),
          target: controls.target.clone(),
          pixelRatio: renderer.getPixelRatio(),
          size: (function(){ const v=new THREE.Vector2(); renderer.getSize(v); return {w:v.x,h:v.y}; })()
        };

        // Focus on the dice mid-air
        controls.autoRotate = false;
        camera.position.set(0, 28, 28);
        controls.target.set(0, 10, 0);
        controls.update();

        // Apply a random spin for motion pose
        dice.rotation.x += Math.random()*Math.PI;
        dice.rotation.y += Math.random()*Math.PI;

        // Render high-res frame
        const W = 1920, H = 1080;
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
        renderer.setSize(W, H, false);
        renderer.render(scene, camera);

        // Download
        const link = document.createElement('a');
        link.download = `ludo_dice_shot_${Date.now()}.png`;
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();

        // Restore
        renderer.setPixelRatio(prev.pixelRatio);
        renderer.setSize(prev.size.w, prev.size.h, false);
        camera.position.copy(prev.camPos);
        controls.target.copy(prev.target);
        controls.autoRotate = prev.autoRotate;
        controls.update();

        showNotification('\ud83c\udfb2 Dice shot captured');
      }catch(err){
        showNotification('Failed to capture dice shot.');
      }
    }

    function bootstrap(){ wireUI(); initThreeWhenReady(); showNotification('\ud83d\udc4b Welcome! Click Start to begin.'); }
    if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', bootstrap); } else { bootstrap(); }
  </script>
</body>
</html>
